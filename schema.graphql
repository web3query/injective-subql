# To improve query performance, we strongly suggest adding indexes to any field that you plan to filter or sort by
# Add the `@index` or `@index(unique: true)` annotation after any non-key field
# https://academy.subquery.network/build/graphql.html#indexing-by-non-primary-key-field

# type Block @entity {
#   id: ID! # The block hash
#   height: BigInt!
# }

# type TransferEvent @entity {
#   id: ID!
#   blockHeight: BigInt!
#   txHash: String!
#   recipient: String!
#   sender: String!
#   amount: String!
# }

type Account @entity {
  id: ID!
  blockHeight: Int!
  timestamp: BigInt!
  address: String!
}

type Transaction @entity {
  id: ID!
  blockHeight: Int!
  timestamp: BigInt!
  status: String!

  "Fee data"
  denom: String
  gasUsed: BigInt!
}

type Contract @entity {
  id: ID!
  blockHeight: Int!

  "Timestamp of the block"
  timestamp: BigInt!

  "Address of the contract"
  address: String!

  "Number of txs for the contract"
  txCount: Int!

  "Number of failed txs for the contract"
  failedTxCount: Int!

  "Total gas used during contract executions"
  gasUsed: BigInt!
}

type Chain @entity {
  id: ID!

  "Last produced block that include at least a tx"
  blockHeight: Int!

  "Timestamp of the block"
  timestamp: BigInt!

  "Name of the chain"
  chainId: String!

  "Number of txs for the chain effective after starting monitor"
  txCount: Int!

  "Number of failed txs for the chain effective after starting monitor"
  failedTxCount: Int!

  "Total gas used for the chain effective after starting monitor"
  gasUsed: BigInt!
}

type SpotLimitOrder @entity {
  id: ID!
  blockHeight: BigInt!
  txHash: String!
  from: String! # sender
  marketID: String!
  orderType: String!
  subAccountID: String!
  feeRecipient: String!
  price: BigInt!
  quantity: BigInt!
  amount: BigInt!
}
